[[toc]]
网络上关于openssl开发的文档比较少，由于项目需要用到AES加解密，倒腾了好几天，也遇到了一些坑，想着不能就这样算了，总得有点收获吧，就整理出这份文档。由于涉及的内容比较有限，无法覆盖openssl全部内容，后续有机会慢慢补充。

# openssl版本
openssl有很多个版本，不同版本的接口有一些区别。网络上的代码可能基于某个版本，在本地可能都编译不过。所以首先得搞清楚现在系统openssl的版本是什么：
```bash
[root@centos ~]# rpm -qa|grep openssl
openssl11-libs-1.1.1g-3.el7.x86_64
openssl-devel-1.0.2k-21.tl2.1.x86_64
openssl098e-0.9.8e-29.el7.centos.2.x86_64
openssl-libs-1.0.2k-21.tl2.1.x86_64
openssl-perl-1.0.2k-21.tl2.1.x86_64
openssl098e-0.9.8e-29.el7.centos.2.i686
openssl-libs-1.0.2k-21.tl2.1.i686
openssl-1.0.2k-21.tl2.1.x86_64
[root@centos ~]# openssl version -a|grep OpenSSL
OpenSSL 1.0.2k-fips  26 Jan 2017
```
可得知当前系统的openssl的版本为1.0.2，对应的openssl官网上文档地址如下：
https://www.openssl.org/docs/man1.0.2/

官网的文档比较少，而且都是英文的，看着费劲，不过除了官网好像也没有什么更好的文档了，凑合着看吧。

# AES加解密
## 原理
AES是一种对称加密算法，由于算法非常好使，很多CPU（例如x86）都在硬件指令级别对该算法提供支持。加解密最小单位称为分组，固定为128位（即16字节）；密钥支持128位、192位、256位三种。由于最小加密单位为16字节，故当明文长度不为16的整数倍时，需要先对明文填充，再加密。
填充算法包括：
 - NoPadding 不填充
 - PKCS 填充字符串由一个字节序列组成，每个字节填充该字节序列的长度。
 - ISO10126 填充字符串由一个字节序列组成，此字节序列的最后一个字节填充字节序列的长度，其余字节填充随机数据。
 - Zeros 填充字符串由设置为零的字节组成。
 - ANSIX923 填充字符串由一个字节序列组成，此字节序列的最后一个字节填充字节序列的长度，其余字节均填充数字零

以下分析PKCS填充流程：
 - 加密填充流程
当明文长度不是16字节整数倍时，缺几个字节就补几个（每个字节为补的字节数量，例如补了10个，后面就是10个值为10的字节）；当明文长度正好是16字节整数倍时，明文后补充16个字节（每个字节值均为16）
 - 解密填充流程
当解密到密文的最后16个字节时，检查解密过后的16个字节，如果最后一个字节的值为16，则舍弃这一串16个字节的数据；如果最后一个字节的值小于16，说明在加密时对原文进行了填充，则舍弃最后填充的部分

主要的加密模式有以下几种：
 - ECB模式
按照块密码的块大小被分为数个块，并对每个块进行独立加密。
 - CBC模式
每个平文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有平文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量
 - FB模式
模式类似于CBC，可以将块密码变为自同步的流密码
 - OFB模式
可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与平文块进行异或，得到密文。

## 实战
这里就不帖代码了，看[官网例子](https://www.openssl.org/docs/man1.0.2/man3/EVP_EncryptInit.html#EXAMPLES)就可以了，主要讲一些要点吧。

AES相关的接口包括三套**EVP_EncryptXXX**、**EVP_DecryptXXX**和**EVP_CipherXXX**。第一套用于加密，包括**EVP_EncryptInit_ex**、**EVP_EncryptUpdate**和**EVP_EncryptFinal_ex**；第二套用于解密，接口类似；第三套对第一、二套进行封装，既可加密，也可解密。

这里EVP是envelope的缩写，表示数据加解密的封装的意思。

### **EVP_EncryptInit_ex**
初始化时需要指明加密模式，比如EVP_aes_256_cbc()表示采用CBC的模式，并且密钥长度为256字节；该函数还需要提供iv和密钥key。
### **EVP_EncryptUpdate**
需要注意的是输入的数据长度和输出数据长度不一定是一样的，如果最后的数据长度非16字节的倍数，就需要调用**EVP_EncryptFinal_ex**
###  **EVP_EncryptFinal_ex**
这里关键点是填充数据，参考上面对PKCS填充流程的描述即可。**EVP_**相关接口已经把填充的功能实现了，所以开发者只需要正确调用接口就可以拿到想要的数据。
